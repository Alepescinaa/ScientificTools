# -*- coding: utf-8 -*-
"""checkpoint2_submission2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1e5kxnftMI1wcx6bVFgR0CvItDW4tPPlQ

# Optimal well disposition for the Darcy problem

## Import
"""

# %%capture
# !git clone https://github.com/Alepescinaa/ScientificTools
# %cd ScientificTools/Project2/Cp2

# !apt-get update
# !apt-get install libglu1-mesa

# !git clone https://github.com/pmgbergen/porepy.git
# %cd porepy

# !git checkout main

# !pip install -r requirements.txt

# !pip install .

# %cd ..

# !pip install pathos

import sys
import scipy
import numpy as np
import porepy as pp
from tqdm import tqdm
#import multiprocessing
import pathos.multiprocessing
from pathos.multiprocessing import _ProcessPool
import scipy.sparse as sps
import matplotlib.pyplot as plt

main_folder = "./"
spe10_folder = main_folder + "spe10"
sys.path.insert(1, spe10_folder)

from functions import *
from spe10 import Spe10

"""## Fine solver"""

def solve_fine(spe10, pos_well, injection_rate=1, well_pressure=0, export_folder=None):
    """
    Compute the averaged gradient and flux for a given subdomain and direction of the pressure
    gradient.

    Args:
        spe10 (object): The object representing the subdomain.
        pos_well (np.ndarray): The position of the production well.
        injection_rate (float, optional): The injection rate of the wells. Defaults to 1.
        well_pressure (float, optional): The pressure at the production well. Defaults to 0.
        export_folder (str, optional): If given, path where to export the results. Defaults to
            None.

    Returns:
        float: The maximum pressure at the injection wells.
    """
    # Extract the grid for simplicity
    sd = spe10.sd
    perm_dict = spe10.perm_as_dict()

    # Permeability
    perm_tensor = pp.SecondOrderTensor(kxx=perm_dict["kxx"])
    #print(perm_tensor)

    # Boundary conditions
    b_faces = sd.tags["domain_boundary_faces"].nonzero()[0]

    # Define the labels and values for the boundary faces
    labels = np.array(["neu"] * b_faces.size)
    bc_val = np.zeros(sd.num_faces)
    bc = pp.BoundaryCondition(sd, b_faces, labels)

    # Collect all parameters in a dictionary
    key = "flow"
    parameters = {"second_order_tensor": perm_tensor, "bc": bc, "bc_values": bc_val}
    data = pp.initialize_default_data(sd, {}, key, parameters)

    # Discretize the problem
    discr = pp.Mpfa(key)
    discr.discretize(sd, data)

    A, b = discr.assemble_matrix_rhs(sd, data)

    # Add the injection wells, all with the same injection rate
    b_wells = np.zeros_like(b)
    index_iwells = [
        0,
        spe10.full_shape[0] - 1,
        spe10.full_shape[0] * spe10.full_shape[1] - spe10.full_shape[0],
        spe10.full_shape[0] * spe10.full_shape[1] - 1,
    ]
    b_wells[index_iwells] = injection_rate

    # Add the production well by using a Lagrange multiplier, first we identify the cell
    ij_well = np.floor((np.asarray(pos_well) / spe10.spacing[:-1])).astype(int)
    #print(ij_well)
    index_pwell = spe10.full_shape[0] * ij_well[1] + ij_well[0]
    vect = np.zeros((sd.num_cells, 1))
    vect[index_pwell] = 1

    # Solve the linear system and compute the pressure by adding the constraint
    A = sps.bmat([[A, vect], [vect.T, None]], format="csc")
    b = np.append(b + b_wells, well_pressure)
    p = sps.linalg.spsolve(A, b)[:-1]

    # extract the discretization matrices build
    mat_discr = data[pp.DISCRETIZATION_MATRICES][key]

    # reconstruct the flux as post-process
    q_tpfa = mat_discr["flux"] @ p + mat_discr["bound_flux"] @ bc_val

    # to export the flux
    mvem = pp.MVEM(key)
    mvem.discretize(sd, data)
    # construct the P0 flux reconstruction
    cell_q_mpfa = mvem.project_flux(sd, q_tpfa, data)


    # Export the solution
    if export_folder is not None:
        save = pp.Exporter(sd, "sol", folder_name=export_folder)
        save.write_vtu([("p", p), ("log_kxx", np.log10(perm_dict["kxx"])),("q_mpfa", cell_q_mpfa)])

    # Return the maximum pressure at the injection wells
    return np.max(p[index_iwells])

"""## Upscaling"""

def upscale(sd, perm, dir, export_folder=None):
    """
    Compute the averaged gradient and flux for a given subdomain and direction of the pressure
    gradient.

    Args:
        sd (pp.Grid): The grid representing the subdomain.
        perm (dict): The permeability of the subdomain divided in the fields "kxx" and "kyy"
        dir (int): The direction of the flow, 0 means x-direction and 1 means y-direction.
        export_folder (str): If given, path where to export the results.
            Default to None, no exporting.

    Returns:
        (np.ndarray, np.ndarray): averaged gradient and flux.
    """
    # Permeability
    perm_tensor = pp.SecondOrderTensor(kxx=perm["kxx"], kyy=perm["kyy"])

    # Boundary conditions
    b_faces = sd.tags["domain_boundary_faces"].nonzero()[0]
    b_face_centers = sd.face_centers[:, b_faces]

    # Find the min and max values of the boundary faces
    sd_min = np.amin(sd.face_centers[dir, :])
    sd_max = np.amax(sd.face_centers[dir, :])

    # define outflow and inflow type boundary conditions
    out_flow = np.isclose(b_face_centers[dir, :], sd_max)
    in_flow = np.isclose(b_face_centers[dir, :], sd_min)

    # define the labels and values for the boundary faces
    labels = np.array(["neu"] * b_faces.size)
    labels[np.logical_or(in_flow, out_flow)] = "dir"

    bc_val = np.zeros(sd.num_faces)
    bc_val[b_faces[in_flow]] = sd_max - sd_min

    bc = pp.BoundaryCondition(sd, b_faces, labels)

    # Collect all parameters in a dictionary
    key = "flow"
    parameters = {"second_order_tensor": perm_tensor, "bc": bc, "bc_values": bc_val}
    data = pp.initialize_default_data(sd, {}, key, parameters)

    # Discretize the problem (construct the lhr and rhs)
    discr = pp.Tpfa(key)
    discr.discretize(sd, data)

    A, b = discr.assemble_matrix_rhs(sd, data)

    # Solve the linear system and compute the pressure
    p = sps.linalg.spsolve(A, b)

    # Export the solution
    if export_folder is not None:
        save = pp.Exporter(sd, "sol", folder_name=export_folder)
        save.write_vtu([("p", p), ("log_perm", np.log10(perm["kxx"]))])

    # Post-process the solution to get the flux
    return compute_avg_q_grad(sd, p, data, key, bc, bc_val)

def compute_tensor(grad_h, grad_v, q_h, q_v):
    """
    Compute the upscaled permeability tensor.

    Args:
        grad_h (np.ndarray): Gradient in the horizontal direction.
        grad_v (np.ndarray): Gradient in the vertical direction.
        q_h (np.ndarray): Flux in the horizontal direction.
        q_v (np.ndarray): Flux in the vertical direction.

    Returns:
        perm (np.ndarray): Upscaled permeability tensor.

    The function solves a linear system to obtain the upscaled permeability tensor
    based on the given gradients and fluxes. It enforces numerical symmetry and
    checks if the resulting tensor is symmetric positive definite (SPD).
    """
    # Solve the linear system to get the upscaled permeability
    lhs = np.array([
        [grad_h[0], grad_h[1], 0, 0],
        [0, 0, grad_h[0], grad_h[1]],
        [grad_v[0], grad_v[1], 0, 0],
        [0, 0, grad_v[0], grad_v[1]],
        [0, 1, -1, 0]
    ])

    rhs = np.array([q_h[0], q_h[1], q_v[0], q_v[1], 0])

    perm = np.linalg.lstsq(lhs, rhs, rcond=None)[0]

    # make it symmetric positive definite
    perm = nearest_spd(perm.reshape(2, 2)).ravel()

    return perm

def process_subdomain(sub_sd_id, sub_sd, perm_dict, folder_results, part, kxx_up, kxy_up, kyx_up, kyy_up):
    mask = part == sub_sd_id
    sub_perm = {key: val[mask] for key, val in perm_dict.items()}

    folder_x = folder_results + str(sub_sd_id) + "_x"
    q_h, grad_h = upscale(sub_sd, sub_perm, 0, folder_x)

    folder_y = folder_results + str(sub_sd_id) + "_y"
    q_v, grad_v = upscale(sub_sd, sub_perm, 1, folder_y)

    kk = compute_tensor(grad_h, grad_v, q_h, q_v)

    return [kk[0], kk[1], kk[2], kk[3]]

def Checkpoint1_solution(selected_layers, grid_dim, folder_results):
    spe10 = Spe10(selected_layers)
    perm_folder = spe10_folder + "/perm/"
    spe10.read_perm(perm_folder)
    perm_dict = spe10.perm_as_dict()

    num_part = grid_dim[0]*grid_dim[1]
    part, sub_sds, sd_coarse = coarse_grid(spe10.sd, num_part)

    kxx_up = np.zeros(spe10.sd.num_cells)
    kxy_up = np.zeros(spe10.sd.num_cells)
    kyx_up = np.zeros(spe10.sd.num_cells)
    kyy_up = np.zeros(spe10.sd.num_cells)
    kxx = np.zeros(spe10.sd.num_cells)

    pool = _ProcessPool(processes = pathos.multiprocessing.cpu_count())
    result = pool.starmap_async(process_subdomain, [(sub_sd_id, sub_sd, perm_dict, folder_results, part, kxx_up, kxy_up, kyx_up, kyy_up) for sub_sd_id, sub_sd in enumerate(sub_sds)]).get()
    pool.close()
    pool.join()

    for sub_sd_id, kk in enumerate(result):
        mask = part == sub_sd_id
        sub_perm = {key: val[mask] for key, val in perm_dict.items()}
        kxx[mask] = sub_perm["kxx"]
        kxx_up[mask], kxy_up[mask], kyx_up[mask], kyy_up[mask] = kk
        #print(f"Subdomain {sub_sd_id}: {kk}")

    var_to_save = [
        ("kxx", np.log10(kxx_up)),
        ("kxy", kxy_up),
        ("kyx", kyx_up),
        ("kyy", np.log10(kyy_up)),
        ("fine", np.log10(kxx))
    ]

    save = pp.Exporter(spe10.sd, "upscaled_k", folder_name=folder_results)
    save.write_vtu(var_to_save)

    write_upscaled_perm("as_tensor", sd_coarse, result, folder_results)

    return sd_coarse, result

"""## Solve coarse"""

def solve_coarse(
    sd,
    pos_well,
    kk,
    grid_dim,
    injection_rate=1,
    well_pressure=0,
    export_folder=None,

):
    """
    Compute the averaged gradient and flux for a given subdomain and direction of the pressure
    gradient.

    Args:
        spe10 (object): The object representing the subdomain.
        pos_well (np.ndarray): The position of the production well.
        injection_rate (float, optional): The injection rate of the wells. Defaults to 1.
        well_pressure (float, optional): The pressure at the production well. Defaults to 0.
        export_folder (str, optional): If given, path where to export the results. Defaults to
            None.

    Returns:
        float: The maximum pressure at the injection wells.
    """

    # Permeability
    result = np.array(kk).T
    perm_tensor = pp.SecondOrderTensor(kxx=result[0], kyy=result[3], kxy=result[1])
    #print(perm_tensor)

    # Boundary conditions
    b_faces = sd.tags["domain_boundary_faces"].nonzero()[0]

    # Define the labels and values for the boundary faces
    labels = np.array(["neu"] * b_faces.size)
    bc_val = np.zeros(sd.num_faces)
    bc = pp.BoundaryCondition(sd, b_faces, labels)

    # Collect all parameters in a dictionary
    key = "flow"
    parameters = {"second_order_tensor": perm_tensor, "bc": bc, "bc_values": bc_val}
    data = pp.initialize_default_data(sd, {}, key, parameters)

    # Discretize the problem
    discr = pp.Mpfa(key)
    discr.discretize(sd, data)

    A, b = discr.assemble_matrix_rhs(sd, data)

    #properties of the grid
    N_x = grid_dim[0]
    N_y = grid_dim[1]
    width = 365.76
    height = 670.56
    spacing = np.array([width / N_x, height / N_y])

    # Add the injection wells, all with the same injection rate
    b_wells = np.zeros_like(b)
    index_iwells = [
        0,
        N_x - 1,
        N_x * N_y - N_x,
        N_x * N_y - 1,
    ]
    b_wells[index_iwells] = injection_rate

    # Add the production well by using a Lagrange multiplier, first we identify the cell
    ij_well = np.floor((np.asarray(pos_well) / spacing)).astype(int)
    #print(ij_well)
    index_pwell = N_x * ij_well[1] + ij_well[0]
    vect = np.zeros((sd.num_cells, 1))
    vect[index_pwell] = 1

    # Solve the linear system and compute the pressure by adding the constraint
    A = sps.bmat([[A, vect], [vect.T, None]], format="csc")
    b = np.append(b + b_wells, well_pressure)
    p = sps.linalg.spsolve(A, b)[:-1]

    # extract the discretization matrices build
    mat_discr = data[pp.DISCRETIZATION_MATRICES][key]

    # reconstruct the flux as post-process
    q_tpfa = mat_discr["flux"] @ p + mat_discr["bound_flux"] @ bc_val

    # to export the flux
    mvem = pp.MVEM(key)
    mvem.discretize(sd, data)
    # construct the P0 flux reconstruction
    cell_q_mpfa = mvem.project_flux(sd, q_tpfa, data)


    # Export the solution
    if export_folder is not None:
        save = pp.Exporter(sd, "sol", folder_name=export_folder)
        save.write_vtu([("p", p), ("log_kxx", np.log10(result[0])),("q_mpfa", cell_q_mpfa)])

    # Return the maximum pressure at the injection wells
    return np.max(p[index_iwells])

"""## Usefull function"""

def compute_bounds_centered(top_xy, spacing):
  x_min = top_xy[0] - spacing[0] / 2
  x_max = top_xy[0] + spacing[0] / 2
  y_min = top_xy[1] - spacing[1] / 2
  y_max = top_xy[1] + spacing[1] / 2

  return x_min, x_max, y_min, y_max

def compute_bounds(top_xy, spacing):
  x_min = top_xy[0]
  x_max = top_xy[0] + spacing[0]
  y_min = top_xy[1]
  y_max = top_xy[1] + spacing[1]

  return x_min, x_max, y_min, y_max

def compute_spacing(grid_dim):
  N_x = grid_dim[0]
  N_y = grid_dim[1]
  width = 365.76
  height = 670.56
  spacing_inter = np.array([width / N_x, height / N_y])

  return spacing_inter

def high_perm_points(grid_points_fine, treshold):
  index = (np.array([np.round(grid_points_fine.T[0] /  spe10.spacing[0]), np.round(grid_points_fine.T[1] /  spe10.spacing[1])]))
  index = index.astype(int)

  spe10.read_perm(perm_folder)
  perm_dict = spe10.perm_as_dict()
  kxx = perm_dict["kxx"]
  perm = np.array(kxx).reshape(60,220)
  selected_perm = perm[index[0], index[1]]
  q_75 = np.percentile(selected_perm, treshold)
  highest_perm_idx = np.where(selected_perm >= q_75)
  selected_points = grid_points_fine[highest_perm_idx]

  return selected_points

"""## Perform upscaling and test functions"""

# selected_layers = 65
# folder_results = main_folder + "results/"

# # Read the SPE10 grid
# spe10 = Spe10(selected_layers)

# # Read the permeability associated to the given layer(s)
# perm_folder = spe10_folder + "/perm/"
# spe10.read_perm(perm_folder)

# # Read the permeability associated to the given layer(s) for coarse grid
# sd_coarse, result = Checkpoint1_solution(selected_layers, [10,10], folder_results)
# sd_intermediate, result_intermediate = Checkpoint1_solution(selected_layers, [20,20], folder_results)

# # Define the function to evaluate that depends only on the position of the injection well

# # CostFunctional = lambda x: solve_coarse(sd_coarse, x, result, grid_dim, export_folder=folder_results)

# # CostFunctionalFine = lambda x: solve_fine(spe10, x, grid_dim, export_folder=folder_results)

# # print(CostFunctional([231, 481]))
# # print(CostFunctionalFine([231, 481]))

"""## Optimization"""

def checkpoint2_solution(selected_layers, folder_results):

  # Read the SPE10 grid
  spe10 = Spe10(selected_layers)

  # Read the permeability associated to the given layer(s)
  perm_folder = spe10_folder + "/perm/"
  spe10.read_perm(perm_folder)

  sd_coarse, result = Checkpoint1_solution(selected_layers, [10,10], folder_results)
  print('Performed coarse upscaling')
  print()
  print('#-------------------------------------------------#')
  print()
  sd_intermediate, result_intermediate = Checkpoint1_solution(selected_layers, [20,20], folder_results)
  print('Performed intermediate upscaling')
  print()
  print('#-------------------------------------------------#')
  print()

  #definition of the position of wells on coarse grid
  grid_dim = [10, 10]
  spacing = compute_spacing(grid_dim)

  starting_point_x = spacing[0] / 2 + spacing[0] * np.arange(10)
  starting_point_y = spacing[1] / 2 + spacing[1] * np.arange(10)

  grid_points = []
  for x in starting_point_x:
      for y in starting_point_y:
          grid_points.append((x, y))

  grid_points = np.array(grid_points)

  print('Starting coarse solver')
  print()

  pool = _ProcessPool(processes = pathos.multiprocessing.cpu_count())
  loss = pool.starmap_async(solve_coarse, [(sd_coarse, x, result, grid_dim, 1, 0, folder_results) for x in (grid_points)]).get()
  pool.close()
  pool.join()

  k = 10
  top = np.argsort(loss)[:k]
  top_xy = grid_points[top].T

  x_min, x_max, y_min, y_max = compute_bounds_centered(top_xy, spacing)

  grid_dim = [20, 20]
  spacing_inter = compute_spacing(grid_dim)

  grid_points_intermediate = []
  for i in range(len(top)):
    vec_x = np.arange(x_min[i], x_max[i] - 1e-5, spacing_inter[0])
    vec_y = np.arange(y_min[i], y_max[i] - 1e-5, spacing_inter[1])
    for x in vec_x:
        for y in vec_y:
            grid_points_intermediate.append((x, y))

  grid_points_intermediate = np.array(grid_points_intermediate)

  print('#-------------------------------------------------#')
  print()
  print('Starting intermediate solver')
  print()

  pool = _ProcessPool(processes = pathos.multiprocessing.cpu_count())
  loss = pool.starmap_async(solve_coarse, [(sd_intermediate, x, result_intermediate, grid_dim, 1, 0, folder_results) for x in (grid_points_intermediate)]).get()
  pool.close()
  pool.join()

  k = 5
  top_inter = np.argsort(loss)[:k]
  top_xy_inter = grid_points_intermediate[top_inter].T

  x_min, x_max, y_min, y_max = compute_bounds(top_xy_inter, spacing_inter)

  spacing_fine_y = 3.048

  grid_points_fine = []
  for i in range(len(top_inter)):
    vec_x = np.arange(x_min[i], x_max[i] - 1e-5, spe10.spacing[0])
    vec_y = np.arange(y_min[i], y_max[i] - 1e-5, spacing_fine_y)
    for x in vec_x:
        for y in vec_y:
            grid_points_fine.append((x, y))

  grid_points_fine = np.array(grid_points_fine)

  #treshold = 60
  #selected_points = high_perm_points(grid_points_fine, treshold)

  print('#-------------------------------------------------#')
  print()
  print('Starting fine solver')
  print()

  pool = _ProcessPool(processes = pathos.multiprocessing.cpu_count())
  loss_fine = pool.starmap_async(solve_fine, [(spe10, x, 1, 0, folder_results) for x in (grid_points_fine)]).get()
  pool.close()
  pool.join()

  top_fine = np.argsort(loss_fine)[0]
  top_xy_fine = grid_points_fine[top_fine].T

  return  top_xy_fine

if __name__ == '__main__':

    selected_layers = 60
    folder_results = main_folder + "results/"

    # Read the SPE10 grid
    spe10 = Spe10(selected_layers)

    # Read the permeability associated to the given layer(s)
    perm_folder = spe10_folder + "/perm/"
    spe10.read_perm(perm_folder)

    top_xy_fine = checkpoint2_solution(selected_layers, folder_results)

    print(top_xy_fine)